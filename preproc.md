# The C Preprocessor
## Overview
Препроцессор C является макропроцессором (`macro` processor),<br/>
который автоматически используется компилятором C для преобразования программы перед компиляцией.<br/>
Он называется макропроцессором, поскольку позволяет определять макросы,<br/>
которые являются краткими сокращениями для более длинных конструкций.
### Initial processing
Препроцессор выполняет серию текстовых преобразований. Это происходит до любой другой обработки.<br/>
Концептуально они происходят в строгом порядке, и весь файл проходит через каждое преобразование перед началом следующего.<br/>
Но фактически `cpp` делает их все сразу, по соображениям производительности.<br/>
Эти преобразования примерно соответствуют первым трем “phases of translation”, описанным в стандарте C.

1. **The input file is read into memory and broken into lines.**<br/>
Если в последней строке любого входного файла отсутствует маркер конца строки, считается, что конец файла неявно указан.<br/>
Стандарт C говорит, что это условие вызывает `UB`, поэтому `gcc` выдаст warning.

2. **If trigraphs are enabled, they are replaced by their corresponding single characters.**<br/>
По умолчанию `gcc` игнорирует триграфы, но есть опция `-trigraphs` для их включения.<br/>
Они не очень популярны и многие компиляторы некорректно их обрабатывают, они практически `deprecated`.<br/>

 |Trigraph:    |   \?\?\( | \?\?\) | \?\?\< | \?\?\> | \?\?\= | \?\?\/ | \?\?\' | \?\?\! | \?\?\- |
 |  :---       |   :---:  |  :---: |  :---: |  :---: |  :---: |  :---: |  :---: |  :---: |  :---: |
 |Replacement: |     [    |    ]   |    {   |     }  |    #   |     \  |    ^   | &#124; |    ~   |
 
&nbsp;&nbsp;3\. **Continued lines are merged into one long line.**<br/>
&emsp;&emsp; Это строки, которые заканчиваются на backslash (`'\'`).<br/>
&emsp;&emsp; Удаляется backslash и следующая строка сливается с текущей строкой.

&nbsp;&nbsp;4\. **All comments are replaced with single spaces.**<br/>
### Tokenization
После завершения текстовых преобразований входной файл преобразуется в последовательность preprocessing токенов.<br/>
Они в основном соответствуют синтаксическим токенам, используемым компилятором C, но есть отличия.<br/>
Токены не обязательно должны быть разделены пробелами, но часто необходимо их добавлять, чтобы избежать неясностей.<br/>
Whitespace отделяет токены, сам по себе это не токен.

**Различия между preprocessor token и compiler token**:
- `cpp` и компилятор могут использовать разные кодировки для character и string literals.
- Компилятор воспринимает integer и floating-point literals по-разному; а `cpp` нет.
- Для `cpp` `<header>` - это один token (for #include directives); для компилятора нет.

**Когда `cpp` имеет различные варианты для токенизации, он поступает жадно (`greedy`)**.<br/>
Он всегда делает каждый токен, начиная слева, насколько можно большим.<br/>
Например: `a+++++b`   interpreted as   `a ++ ++ + b`, а не `a ++ + ++ b`,<br/>
даже не смотря на то, что второй вариант может быть частью валидной программы, а первый нет.

**Как только входной файл разбит на токены**, границы токенов никогда не изменятся, за исключением случая,<br/>
когда `cpp` оператор `##` используется для вставки токенов вместе. См. `Concatenation` далее.<br/>
Например:
```c
#define foo() bar
foo()baz
     → bar baz
not
     → barbaz
```
Компилятор не делает `re-tokenize` вывода препроцессора,<br/>
то есть не токенизирует всё с нуля, он переводит полученные preprocessor tokens в свои токены.

**Preprocessing tokens** можно поделить на 5 классов: identifiers, preprocessing numbers, string literals, punctuators, and other.<br/>
`identifier` имеет такое же значение как и в C: любая последовательность букв, цифр или подчеркивания, которая начинается с буквы или подчеркивания.<br/>
В качестве `extension` в `gcc` символ `$` воспринимается как letter.<br/>
Keywords языка C ничего не значат для `cpp`, для него это просто `identifiers`.<br/>
Поэтому например можно объявить `macro`, чьё имя является `keyword`.<br/>
Единственный `identifier`, который можно назвать `keyword` для `cpp` - это `defined`.
### Overview summary
The preprocessing language состоит из directives to be executed and macros to be expanded.<br/>
Его задачи:

- **Inclusion of header files**.
- **Macro expansion**.<br/>
Можно определять макросы, которые являются алиасами для произвольных фрагментов кода C.<br/>
Препроцессор заменит макросы их определениями по всей программе. Некоторые макросы определяются заранее.
- **Conditional compilation**.<br/>
Можно включать/исключать части кода программы на основании каких-либо условий.
- **Line control**.<br/>
Используется некоторыми инструментами автоматической генерации кода.
- **Diagnostics**.<br/>
Можно обнаружить проблемы во время компиляции и выдать ошибки или предупреждения.

В отличии от `macro expansion`, все перечисленные операции запускаются с помощью `preprocessing directives`.<br/>
Директивы препроцессора - это строки, начинающиеся с `#`. До и после `#` разрешён whitespace.<br/>
После `#` следует identifier, это `directive name`, оно обозначает какую операцию надо выполнить (`#name`).<br/>

Важно, что `#`, с которого начинается директива, не может быть результатом `macro expansion`, также как и `directive name`.<br/>
Например, если `foo` объявлен как macro expanding to `define`, то `#foo` не становится из-за этого валидной директивой.<br/>

Нельзя объявлять свои директивы.<br/>
Также директива препроцессора не может занимать больше 1 строки, но есть выход в виде `backslash-newline`.
## Header Files
Заголовочные файлы содержат C `declarations` и `macro definitions`, для того чтобы их можно было использовать в разных файлах.<br/>
В начале нам надо запросить (подключить) заголовочный файл, делается это с помощью директивы `#include`.

- **System header files** declare the interfaces to parts of the operating system.<br/>
Вы включаете их, чтобы предоставить определения и объявления, необходимые для системных вызовов и библиотек.
- **Собственные header files**.<br/>
Содержат собственные объявления и определения макросов.

Включение (`include`) заголовочного файла даёт те же результаты, что и копирование его в каждый исходный файл, который в этом нуждается.<br/>
### Include Syntax
Данный вариант используется **для system header files**.<br/>
Он ищет файл с именем `file` в стандартном списке системных директорий.<br/>
Вы можете добавить каталоги в список system directories, с помощью опции `-I`.
```c
#include <file>
```
Это вариант используется **для собственных header files**.<br/>
Он ищет файл с именем `file` сначала в каталоге, содержащем текущий файл, затем в quote directories<br/>
и затем в тех же каталогах, которые использовались для `#include <file>`.<br/>
Вы можете добавить каталоги в список quote directories, с помощью опции `-iquote`.
```c
#include "file"
```
Аргумент директивы `#include` воспринимается как строковая константа,<br/>
внутри которой комментарии не распознаются и не происходит `macro expansion`.<br/>
Таким образом, `#include <x / * y>` указывает на включение системного заголовочного файла с именем `x / * y`.
### Include Operation
Директива `#include` заставляет препроцессор сканировать указанный файл в качестве входных данных,<br/>
прежде чем продолжить работу с остальной частью текущего файла.<br/>
Выходные данные препроцессора содержат уже сгенерированный вывод, за которым следует вывод, полученный из включенного файла, за которым следует вывод,<br/>
полученный из текста после директивы #include.
 
Например, если у вас есть `header.h`, содержащий:
```c
char *test (void);
```
И основная программа `program.c`:
```c
int x;
#include "header.h"

int main (void)
{
  puts (test ());
}
```
То компилятор увидит такой же `token stream`, как если бы `program.c` была:
```c
int x;
char *test (void);

int main (void)
{
  puts (test ());
}
```
Любой фрагмент кода может быть включён (`included`) из другого файла, не только declarations и macros, но они, конечно, основные.<br/>
Единственное требование в том, что included file должен состоять из полных (`complete`) токенов.<br/>
Например комментарии или строковые литералы, которые не были закрыты до конца `included` файла, считаются ошибочными.
### Once-Only Headers
Если заголовочный файл будет включен дважды, компилятор обработает его содержимое дважды.<br/>
Это может привести к ошибке, например, когда компилятор видит одно и то же определение структуры.<br/>
Даже если это не так, это, безусловно, будет тратить время.

Стандартный способ предотвратить это состоит в том, чтобы заключить все реальное содержимое файла в условное выражение, иногда это называют `include guard`:
```c
/* File foo.  */
#ifndef FILE_FOO_SEEN
#define FILE_FOO_SEEN

the entire file

#endif /* !FILE_FOO_SEEN */
```
Препроцессор не будет включать данный файл дважды, таким образом компилятор увидит его только один раз.<br/>
Макрос `FILE_FOO_SEEN` называют `controlling macro` или `guard macro`.

В пользовательских файлах macro name не должно начинаться с `_`,<br/>
а в системных наоборот должно начинаться с `_`, чтобы избежать конфликты с пользовательскими файлами.
#### pragma once
Является удобной заменой для `#ifndef wrapper`, но не включен в стандарт.
### Computed Includes
Иногда необходимо выбрать один из нескольких заголовочных файлов для включения в вашу программу.<br/>
Это можно сделать например с помощью ряда условий:
```c
#if SYSTEM_1
# include "system_1.h"
#elif SYSTEM_2
# include "system_2.h"
#elif SYSTEM_3
…
#endif
```
Вместо этого можно использовать macro в качестве имени файла, это называется `computed include`:
```c
#define SYSTEM_H "system_1.h"
…
#include SYSTEM_H
```
## Macros
**Макрос** - это фрагмент кода, которому дано имя.

Всякий раз, когда имя используется, оно заменяется содержимым макроса.<br/>
Есть **два вида** макросов. Они отличаются в основном тем, как они выглядят, когда их используют.<br/>
**Подобные объектам** макросы напоминают объекты данных при использовании, **подобные функциям** макросы напоминают вызовы функций.

В качестве макроса можно указать практически любой валидный `identifier`, даже если это С keyword.<br/>
Препроцессор ничего не знает об этих keywords, что может быть полезно,<br/>
если мы например хотим скрыть какой-то keyword, допустим `const`, от старого компилятора.

Но есть и исключения, не любой `identifier` подойдёт в качестве имени макроса.<br/>
Например `defined` не подойдёт, также не подойдут C++ Named Operators (подробнее о них дальше).
### Object-like Macros
Это простой `identifier`, который будет заменён фрагментом кода.<br/>
Самое частое использование - это создание числовых констант.
```c
#define BUFFER_SIZE 1024
```
Если после этого `#define` встречается например:
```c
foo = (char *) malloc (BUFFER_SIZE);
```
Тогда препроцессор распознает и заменит `BUFFER_SIZE` на соответствующее число.<br/>
Для компилятора это будет выглядеть так, как будто на вход получено:
```c
foo = (char *) malloc (1024);
```
Принято macro names делать `uppercase`.<br/>
Тело макроса заканчивается в конце `#define`-строки, но можно продолжить его на нескольких строках, используя `backslash-newline`.<br/>
При macro expansion, он будет занимать одну строку, а не несколько:
```c
#define NUMBERS 1, \
                2, \
                3
int x[] = { NUMBERS };
     → int x[] = { 1, 2, 3 };
```
Препроцессор сканирует программу последовательно, макросы вступают в силу в месте их появления.
Из кода:
```c
foo = X;
#define X 4
bar = X;
```
Получаем:
```c
foo = X;
bar = 4;
```
Результат `macro expansion` заменяет `macro invocation`, затем полученный результат проверяется на ещё дополнительный макросы.<br/>
Иными словами, может быть макрос внутри макроса:
```c
#define TABLESIZE BUFSIZE
#define BUFSIZE 1024
TABLESIZE
     → BUFSIZE
     → 1024
```
Здесь `TABLESIZE` expands первый раз, превращаясь в `BUFSIZE`, далее превращается уже в `1024`.<br/>
Обратите внимание, что `BUFSIZE` не был определён, когда мы определяли `TABLESIZE`.<br/>
Только когда мы уже использовали `TABLESIZE`, был произведён поиск дополнительного макроса.

Если поменять значение `BUFSIZE` где-то в исходном файле, то `TABLESIZE` также поменяет значение,<br/>
он будет использовать значение `BUFSIZE`, которое в данный момент находится в силе.
```c
#define BUFSIZE 1020
#define TABLESIZE BUFSIZE
#undef BUFSIZE
#define BUFSIZE 37
```
Теперь `TABLESIZE` expands to `37`.
### Function-like Macros
Это макросы, использование которых напоминает вызов функции.
```c
#define lang_init()  c_init()
lang_init()
     → c_init()
```
`Function-like` макрос expands только в том случае, если сразу после его имени следует пара скобок.<br/>
Если вы напишите только имя, оно останется не тронутым.<br/>
Это может быть полезно, когда у вас есть функция и макрос с одинаковым именем, и вы хотите иногда использовать эту функцию:
```c
extern void foo(void);
#define foo() /* optimized inline version */
  …
  foo();            // will use the macro
  funcptr = foo;    // will get the address of the real function
```
Если добавить пробелы перед скобками в определении `function-like macro`, то будет объявлен `object-like macro`,<br/>
у которого начало `expansion` начинается с `()`:
```c
#define lang_init ()    c_init()
lang_init()
     → () c_init()()
``` 
### Macro Arguments
`Function-like` макросы могут принимать аргументы.<br/>
Для того, чтобы объявить макрос, использующий аргументы, мы вставляем параметры между скобками при объявлении макроса.<br/>
Параметры макроса должны быть valid C identifiers.
```c
#define min(X, Y)  ((X) < (Y) ? (X) : (Y))

x = min(a, b);        →  x = ((a) < (b) ? (a) : (b));
y = min(1, 2);        →  y = ((1) < (2) ? (1) : (2));
z = min(a + 28, *p);  →  z = ((a + 28) < (*p) ? (a + 28) : (*p));
```
Все аргументы макроса полностью раскрываются (macro expanded), прежде чем они подставляются в тело макроса.<br/>
После подстановки весь текст снова сканируется для расширения, включая аргументы.
К примеру:
```c
min (min (a, b), c)
```
Сначала расширяется в:
```c
  min (((a) < (b) ? (a) : (b)), (c))
```
А затем уже в:
```c
((((a) < (b) ? (a) : (b))) < (c)
 ? (((a) < (b) ? (a) : (b)))
 : (c))
```
(записано в несколько строк для наглядности, на самом деле будет одна строка)

**Параметры макроса, появляющиеся внутри строковых литералов, не заменяются соответствующими фактическими аргументами.**
```c
#define foo(x) x, "x"
foo(bar) → bar, "x"
```
### Stringizing
Иногда может понадобиться сконвертировать аргумент макроса в строку.<br/>
Когда параметр макроса используется с начальным символом `#`, препроцессор заменяет его текстом фактического аргумента, преобразованным в строковую константу.<br/>
В отличие от обычной замены параметров, аргумент `not macro-expanded first`. Это называется `stringizing`.
```c
#define WARN_IF(EXP) \
do { if (EXP) \
        fprintf (stderr, "Warning: " #EXP "\n"); } \
while (0)
...
WARN_IF (x == 0);
     → do { if (x == 0)
           fprintf (stderr, "Warning: " "x == 0" "\n"); } while (0);
```
`Stringizing` ключает в себя нечто большее, чем добавление двойных кавычек по краям.<br/>
Препроцессор экранирует (с помощью `backslash`) кавычки, окружающие встроенные строковые константы и все `backslashes` в строковых и символьных константах.<br/>
Делает всё это для того, чтобы получить валидную строковую константу.<br/>
Таким образом результатом `stringizing` для `p = "foo\n";` является `"p = \"foo\\n\";"`.<br/>
Но `backslashes`, которые не находятся внутри строковых или символьных констант не дублируются: `\n` stringizes to `"\n"`.

Если мы хотим `stringize` результат `macro expansion`, тогда надо использовать два уровня макросов:
```c
#define xstr(s) str(s)
#define str(s) #s
#define foo 4

str (foo)
     → "foo"
xstr (foo)
     → xstr (4)
     → str (4)
     → "4"
```
`s` у нас `stringized` в `str`, поэтому там она не macro-expanded first.<br/>
но во втором случае для `xstr` это просто аргумент, поэтому срабатывает macro-expansion к 4.
### Concatenation
Бывает полезно объединить два токена в один при macro expansion.<br/>
Это называется `token pasting` или `token concatenation`. Оператор препроцессора `##` выполняет вставку токена.

Однако, если два токена не формирует вместе валидный токен, то они не могут быть обьединены.<br/>
Например мы не можем объединить `x` и `+`, в любом порядке.

Как и с `Stringizing`, аргумент `not macro-expanded first`.

Рассмотрим пример:
```c
struct command
{
  char *name;
  void (*function) (void);
};


struct command commands[] =
{
  { "quit", quit_command },
  { "help", help_command },
  …
};
```
Вместо дублирования имени команды каждый раз, можем сделать следующее:
```c
#define COMMAND(NAME)  { #NAME, NAME ## _command }

struct command commands[] =
{
  COMMAND (quit),
  COMMAND (help),
  …
};
```
### Variadic macros
Макрос может быть объявлен так, чтобы принимать переменное число аргументов.<br/>
Синтаксис определения макроса аналогичен синтаксису функции. Вот пример:
```c
#define eprintf(…) fprintf (stderr, __VA_ARGS__)
```
Такой макрос называется `variadic`, когда такой макрос invoked, все токены в его argument list,<br/>
после крайнего именованного аргумента (в данном примере такого нет), включая все запятые, становятся `variable argument`.<br/>
Эта последовательность токенов заменяет  identifier `__VA_ARGS__` в теле макроса, если он встречается.
```c
eprintf ("%s:%d: ", input_file, lineno)
     →  fprintf (stderr, "%s:%d: ", input_file, lineno)
```
`Variable argument` полностью macro expanded перед вставкой в macro expansion, как и любой обычный аргумент.<br/>
Можно использовать операторы `#` и `##` с `variable argument`.
### Predefined Macros
Их довольно много, рассмотрим здесь только малую часть.

`__FILE__` - expands в имя текущего файла, в виде C string constant.<br/>
Это путь, по которому `cpp` открыл файл, не короткое имя (как в #include).

`__LINE__` - expands в номер текущей строки, в виде decimal integer constant.<br/>
Это довольно странный макрос, так как его "определение" меняется с каждой новой строкой.

`__func__` - expands в имя текущей функции.

`__cplusplus` - этот макрос defined, когда используется С++ компилятор.<br/>
Его можно использовать для проверки какой компилятор используется - C или С++.
### Undefining and Redefining Macros
Оператор `#undef` принимает один аргумент, имя макроса to undefine.<br/>
Даже если макрос `function-like` передаём его имя без скобок.<br/>
Применение `#undef` не к макросу не имеет никакого эффекта.
```c
#define FOO 4
x = FOO;        → x = 4;
#undef FOO
x = FOO;        → x = FOO;
```
После того как макрос был undefined, его можно заново определить (redefine) с помощью `#define`.<br/>
Новое определение макроса не обязано иметь какое-либо сходство со старым определением.

Однако, если текущий (действующий) макрос переопределяется (redefine), тогда новое определение обязано быть `effectively the same` со старым.<br/>
Два macro определения `effectively the same`, если:
- Both are the same type of macro (object- or function-like).
- All the tokens of the replacement list are the same.
- If there are any parameters, they are the same.
- Whitespace appears in the same places in both. It need not be exactly the same amount of whitespace, though. Remember that comments count as whitespace.

Следующие определения `effectively the same`:
```c
#define FOUR (2 + 2)
#define FOUR         (2    +    2)
#define FOUR (2 /* two */ + 2)
```
А следующие нет:
```c
#define FOUR (2 + 2)
#define FOUR ( 2+2 )
#define FOUR (2 * 2)
#define FOUR(score,and,seven,years,ago) (2 + 2)
```
Если макрос переопределен с определением, которое `not effectively the same` со старым, препроцессор выдает `warning`<br/>
и меняет макрос на новое определение. Если новое определение `effectively the same`, переопределение молча игнорируется.<br/>
Это позволяет, например, двум разным заголовкам определять общий макрос. Препроцессор будет жаловаться, только если определения не совпадают.
### Macro Pitfalls
#### Misnesting
Когда макрос вызывается с аргументами, аргументы подставляются в тело макроса,<br/>
и результат проверяется вместе с остальной частью входного файла на наличие дополнительных вызовов макроса.<br/>
Можно например делать так:
```c
#define twice(x) (2*(x))
#define call_with_1(x) x(1)

call_with_1 (twice)
     → twice(1)
     → (2*(1))
```
Определения макросов не обязаны быть сбалансированными (правильными) скобочными последовательностями.<br/>
Создавая незакрытые скобки, можно создать macro вызов, который будет продолжаться за пределами тела макроса, лучше на примере:
```c
#define strange(file) fprintf (file, "%s %d",
…
strange(stderr) p, 35)
     → fprintf (stderr, "%s %d", p, 35)
```
Такие вызовы лучше избегать, стоит держать скобки сбалансированными.
#### Operator Precedence Problems
Представим, мы объявили macro следующим образом:
```c
#define ceil_div(x, y) (x + y - 1) / y
```
Допустим используем так:
```c
a = ceil_div (b & c, sizeof (int));
     → a = (b & c + sizeof (int) - 1) / sizeof (int);
```
Из-за operator-precedence rules of C получаем:
```c
a = (b & (c + sizeof (int) - 1)) / sizeof (int);
вместо
a = ((b & c) + sizeof (int) - 1)) / sizeof (int);
```
Вышло не то, что мы ожидали, поэтому необходимо заключать аргументы макроса в скобки:
```c
#define ceil_div(x, y) ((x) + (y) - 1) / (y)
```
Рассмотрим теперь `sizeof ceil_div(1, 2)`, получаем:
```c
sizeof ((1) + (2) - 1) / (2)
```
Опять не то, получили `sizeof`, делённый пополам.<br/>
Поэтому надо не только брать аргументы в скобки, но и всё тело макроса в скобки.

**Финальная версия**:
```c
#define ceil_div(x, y) (((x) + (y) - 1) / (y))
```
#### Swallowing the Semicolon
Довольно часто требуется написать макрос, который расширяется в `compound statement`.<br/>
Рассмотрим следующий пример, тут указатель сдвигается, пропуская тем самым пустые символы:
```c
#define SKIP_SPACES(p, limit)  \
{ char *lim = (limit);         \
  while (p < lim) {            \
    if (*p++ != ' ') {         \
      p--; break; }}}
```
Вызов данного макроса может иметь вид `SKIP_SPACES(p, lim)`, то есть он расширяется в `compound statement`,<br/>
который является complete statement, не требующим `;` в конце.

Это может вызывать трудности при использовании перед `else` statements, потому что semicolon (`;`) это `null statement`.<br/>
Если написать:
```c
if (*p != 0)
  SKIP_SPACES (p, lim);
else …
```
То получим невалидный код, поскольку между `if condition` и `else` находятся `compound statement` и `null statement`.

Это можно исправить с помощью **do-while**:
```c
#define SKIP_SPACES(p, limit)     \
do { char *lim = (limit);         \
     while (p < lim) {            \
       if (*p++ != ' ') {         \
         p--; break; }}}          \
while (0)
```
Теперь `SKIP_SPACES (p, lim);` расширяется в:
```c
do {…} while (0);
```
#### Duplication of Side Effects
Многие объявляют макрос для поиска минимума таким образом:
```c
#define min(X, Y)  ((X) < (Y) ? (X) : (Y))
```
Если аргумент такого макроса содержит side effect, как например здесь:
```c
next = min (x + y, foo (z));
```
Результат будет следующим:
```c
next = ((x + y) < (foo (z)) ? (x + y) : (foo (z)));
```
Получаем два вызова функции `foo` и два сложения `x+y`.<br/>

В идеале написать данный макрос так, чтобы не было лишних вычислений.<br/>
Но, к сожалению, принятого (standard) способа нет. Но есть GNU Extension, например, который позволяет писать так:
```c
#define min(X, Y)                \
({ typeof (X) x_ = (X);          \
   typeof (Y) y_ = (Y);          \
   (x_ < y_) ? x_ : y_; })
```
Запись `({ … })` создаёт `compound statement`, которое ведёт себя как `expression`, его значение - это значение последнего statement.<br/>
В данном примере мы объявляем локальные переменные `x_`, `y_`, чтобы не считать одно и то же несколько раз.<br/>
Имена данных переменных содержат `_` для того, чтобы уменьшить риск пересечения имён с внешними переменными<br/>
(полностью защититься от этого невозможно).

Если мы не хотим использовать GNU C Extensions, тогда единственный выход из ситуации это использовать макросы аккуратно.<br/>
Следить за тем, чтобы аргументы не имели side effects. Например, перед вызовом макроса можно вычислить и сохранить значения аргументов:
```c
int tem = foo(z);
next = min(x + y, tem);
```
#### Self-Referential Macros
Это макрос, чьё имя встречается в его же определении (похоже на рекурсию).

Как мы знаем, обычно макросы сканируются несколько раз для поиска в них других макросов,<br/>
если же в случае `self-referential` macros мы бы действовали по такой логике, то мы бы уходили в бесконечное расширение исходного макроса.<br/>
Для того, чтобы это избежать, `self-reference` не считается за macro call и остаётся нетронутым:
```c
#define foo (4 + foo)
```
Если бы `self-reference` расширялся бы как обычный макрос, то мы бы получили `(4 + (4 + foo))` и так далее, пока бы у нас не закончилась memory.<br/>
Но правило работы с `self-reference` останавливает этот процесс сразу, на первом шаге, раскрываясь в `(4 + foo)`.<br/>
Хоть процесс остановлен после первого шага, эффект всё-таки есть, такое определение заставляет увеличивать значение `foo` на 4 каждый раз, когда к нему идёт обращение.

В любом случае такое лучше не использовать из-за своей неочевидности. Человек, читающий программу, увидит что `foo` является переменной<br/>
и может не подумать, что есть макрос с таким же именем, и что на самом деле здесь значение переменной `foo` увеличено на 4.

**Полезное применение**: макрос, который расширяется в самого себя
```c
#define EPERM EPERM
```
Таким образом макрос `EPERM` превращается в `EPERM` при использовании, но также доступен и с `#ifdef`.<br/>
Можно использовать такое например, если хотим объявить числовые константы с помощью enum, но и чтобы `#ifdef` был `true` для каждой константы.

Если макрос `x` расширяется и использует макрос `y`, который в свою очередь использует макрос `x`,<br/>
то это косвенная (`indirect self-reference`) ссылка на себя, в таком случае тоже останавливается процесс расширения:
```c
#define x (4 + y)
#define y (2 * x)

x    → (4 + y)
     → (4 + (2 * x))

y    → (2 * x)
     → (2 * (4 + y))
```
#### Argument Prescan
Аргументы макроса полностью macro expanded перед подстановкой (передачей в макрос).<br/>
После подстановки тело макроса снова сканируется на наличие macros to be expanded.<br/>

В результате получается, что аргументы макроса сканируются два раза.<br/>
В большинстве случаев это не обязательно, то есть достаточно было бы и одного сканирования.<br/>
Ведь если аргументы содержат макро-вызовы, то после первого сканирования они бы уже раскрылись и второе сканирование уже бы не было обязательным.<br/>
Так зачем нужен prescan?

**Argument Prescan играет роль в трёх случаях**:

1\) **Nested calls to a macro**<br/>
`Nested call` - это когда аргумент макроса содержит вызов этого макроса. Например: `f (f (1))`.<br/>
 Поскольку аргументы сперва полность macro expanded, то `f(1)` раскроется и подставится в `f`, всё работает как задумано.<br/>
 Что если бы не было `argument prescan`? Тогда бы `f(1)` не раскрылось и подставилось в `f` как есть и<br/>
 мы бы получили `self-referential` macro, поскольку в теле `f` был бы вызов `f` и `macro expansion` остановилось бы.
 
2\) **Macros that call other macros that stringize or concatenate.**<br/>
Если аргумент `stringized` или `concatenated`, тогда нет argument prescan.<br/>
В случае, когда нам нужно сначала сделать macro expansion и только потом уже stringize/concatenate, можно сделать это через вспомогательный макрос:
```c
#define AFTERX(x) X_ ## x
#define XAFTERX(x) AFTERX(x)
#define TABLESIZE 1024
#define BUFSIZE TABLESIZE
```
Тогда
```c
AFTERX(BUFSIZE) → X_BUFSIZE
XAFTERX(BUFSIZE) -> X_1024
```

3\) **Macros used in arguments, whose expansions contain unshielded commas.**<br/>
```c
#define foo  a,b
#define bar(x) lose(x)
#define lose(x) (1 + (x))
```
Хотелось бы, чтобы `bar(foo) → (1 + (foo)) → (1 + (a,b))`.<br/>
Но получаем `bar(foo) → bar(a,b) → lose(a,b)` и тут ошибка, так как передаётся два аргумента в макрос `lose`.<br/>
Проблема решается добавлением скобок: `#define foo (a,b) or #define bar(x) lose((x))`
## Conditionals
Это директивы, с помощью которых можно выбирать включить фрагмент кода или нет.
### Ifdef
```c
#ifdef MACRO

controlled text

#endif /* MACRO */
```
Это называется `conditional group`, `controlled text` будет включён в вывод препроцессора только если `MACRO` defined.<br/>
Если `MACRO` defined, то говорим, что conditional succeeds, иначе fails.<br/>
Внутри `controlled text` могут находиться preprocessing directives, они будут выполняться только если conditional succeeds.<br/>
Могут быть вложенные conditional groups.
##### Ifndef
Противоположность `ifdef`.
### If
Позволяет проверять значение арифметического выражения, а не просто наличие макроса.
```c
#if expression

controlled text

#endif /* expression */
```
Где `expression` - C-выражение целочисленного типа, на которое распространяются строгие ограничения, может содержать:

- Integer constants.
- Character constants, which are interpreted as they would be in normal code.
- +,-,*,/, bitwise operations, shifts, comparisons, logical operations (&& and ||).
- Macros.
- Использование оператора `defined`, который позволяет определять объявлен ли макрос, прямо в `#if`.
### Defined
Оператор `defined` используется в `#if` и `#elif` выражениях для проверки объявлено ли данное имя как макрос.<br/>
Выражения `defined name` и `defined (name)` имеют значение 1, если `name` макрос и 0 в противном случае.<br/>
Таким образом `#if defined MACRO` практически то же самое, что и `#ifdef MACRO`.

Полезно использовать `defined`, когда нужно проверить существование сразу нескольких макросов:
```c
#if defined (__vax__) || defined (__ns16000__)
```
Следующее выражение
```c
#if defined BUFSIZE && BUFSIZE >= 1024
```
Можно упростить в:
```c
#if BUFSIZE >= 1024
```
Поскольку если `BUFSIZE` not defined, то это будет интерпретировано так, будто его значение `0`.

Если defined operator является результатом macro expansion, то C стандарт описывает это как undefined behavior.<br/>
Для включения warning на эту тему можно передать `-Wexpansion-to-defined`.
### Else
Если `expression` nonzero, тогда `text-if-true` включён и `text-if-false` пропускается. Если `expression` zero, тогда наоборот.
```c
#if expression
text-if-true
#else /* Not expression */
text-if-false
#endif /* Not expression */
```
### Elif
```c
#if X == 1
…
#elif X == 2
…
#else /* X != 2 and X != 1*/
…
#endif /* X != 2 and X != 1*/
```
## Diagnostics
Директива `#error` сообщает о фатальной ошибке.
```c
#ifdef __vax__
#error "Won't work on VAXen.  See comments at get_last_object."
#endif
```
```c
#if !defined(FOO) && defined(BAR)
#error "BAR requires FOO."
#endif
```
Также есть ещё и `#warning` директива, в отличии от `#error` она не останавливает препроцессинг.<br/>
Ни `#error`, ни `#warning` не расширяют свои аргументы (no macro-expands).
